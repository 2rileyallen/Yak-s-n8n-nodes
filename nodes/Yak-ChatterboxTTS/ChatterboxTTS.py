import sys
import json
import os
import tempfile
import torchaudio as ta
from chatterbox.tts import ChatterboxTTS
import warnings
import subprocess
from contextlib import redirect_stdout, redirect_stderr
import io
import shutil

# Suppress ignorable warnings from libraries
warnings.filterwarnings("ignore", category=FutureWarning)

# Determine the processing device (GPU if available, otherwise CPU)
import torch
device = "cuda" if torch.cuda.is_available() else "cpu"


def ensure_wav(input_path: str, temp_files: list) -> str:
    """
    Ensures the given audio file is in WAV format for model processing.
    If it's not a WAV file, it uses FFmpeg to convert it to a temporary WAV file.
    This temporary file is tracked for later cleanup.

    Args:
        input_path: The absolute path to the input audio file.
        temp_files: A list to which the path of any created temp file will be added.

    Returns:
        The path to the WAV file (either the original or the new temporary one).
    """
    # If the file is already a .wav, no conversion is needed.
    if input_path and input_path.lower().endswith(".wav"):
        return input_path

    # Create a temporary file to hold the converted WAV audio.
    output_wav_path = tempfile.NamedTemporaryFile(delete=False, suffix=".wav").name
    temp_files.append(output_wav_path)
    try:
        # Construct and run the FFmpeg command for conversion.
        cmd = ["ffmpeg", "-y", "-i", input_path, output_wav_path]
        subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except (subprocess.CalledProcessError, FileNotFoundError) as e:
        raise RuntimeError(
            f"FFmpeg conversion failed for '{input_path}': {e}. Ensure FFmpeg is installed and in your system's PATH."
        ) from e

    return output_wav_path


def convert_and_save_output(wav_path: str, desired_extension: str, temp_files: list) -> str:
    """
    Converts the raw WAV output from the model to the desired final format
    and saves it to a unique file in the temporary output directory.

    Args:
        wav_path: The path to the temporary WAV file generated by the model.
        desired_extension: The file extension for the final output (e.g., '.mp3', '.wav').
        temp_files: A list for tracking temporary files for cleanup.

    Returns:
        The absolute path to the final, converted temporary output file.
    """
    # Define the directory for temporary outputs
    temp_output_dir = os.path.join(os.getcwd(), "temp", "output")
    os.makedirs(temp_output_dir, exist_ok=True)

    # Create a unique path for the final output file in the temp directory
    final_output_path = tempfile.NamedTemporaryFile(
        delete=False,
        dir=temp_output_dir,
        suffix=desired_extension
    ).name

    # If the desired format is WAV, we can just move the file.
    if desired_extension.lower() == ".wav":
        shutil.move(wav_path, final_output_path)
    else:
        # For other formats, use FFmpeg to convert the audio.
        try:
            cmd = ["ffmpeg", "-y", "-i", wav_path, final_output_path]
            subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            # The original WAV is no longer needed after conversion.
            temp_files.append(wav_path)
        except Exception as e:
            raise RuntimeError(f"Failed to convert temporary output to {desired_extension}: {e}")

    return final_output_path


def main():
    # This list will keep track of all temporary files created during execution.
    temp_files = []
    try:
        # The script now expects one argument: the path to the JSON payload file.
        if len(sys.argv) < 2:
            raise ValueError("Missing JSON payload file path argument.")
        json_payload_path = sys.argv[1]

        # Read the JSON payload, explicitly using UTF-8 encoding to prevent errors.
        with open(json_payload_path, 'r', encoding='utf-8') as f:
            input_data = json.load(f)

        mode = input_data.get("mode")
        # Default to .mp3 if no specific extension is requested by the TypeScript node.
        output_extension = input_data.get("output_extension") or ".mp3"
        if not output_extension.startswith('.'):
            output_extension = '.' + output_extension

        # --- Resolve and prepare input audio files ---
        target_voice_path = ensure_wav(input_data.get("target_voice_path"), temp_files)
        if not target_voice_path:
            raise ValueError("A target voice file path is required.")

        # Suppress verbose model loading output from Chatterbox
        with redirect_stdout(io.StringIO()), redirect_stderr(io.StringIO()):
            model = ChatterboxTTS.from_pretrained(device=device)
            generate_kwargs = {
                "audio_prompt_path": target_voice_path,
                "exaggeration": input_data.get("exaggeration", 0.5),
                "cfg_weight": input_data.get("cfg_weight", 0.5),
            }

        # --- Perform Core Operation (TTS or VC) ---
        if mode == "tts":
            text = input_data.get("text")
            if not text:
                raise ValueError("Text input is required for TTS mode.")
            wav = model.generate(text, **generate_kwargs)

        elif mode == "vc":
            source_audio_path = ensure_wav(input_data.get("source_audio_path"), temp_files)
            if not source_audio_path:
                raise ValueError("Source audio file path is required for VC mode.")
            wav = model.generate(source_audio_path, **generate_kwargs)
        else:
            raise ValueError(f"Invalid operation mode provided: {mode}")

        # --- Save and Convert Output ---
        # First, save the raw model output to a temporary WAV file.
        with tempfile.NamedTemporaryFile(delete=False, suffix=".wav") as tmpwav:
            ta.save(tmpwav.name, wav, model.sr)
            raw_wav_output_path = tmpwav.name

        # Second, convert this raw WAV to the desired format and save it.
        final_temp_path = convert_and_save_output(raw_wav_output_path, output_extension, temp_files)

        # The script's only successful output is the path to the final temp file.
        print(final_temp_path, end='')

    except Exception as e:
        # On error, print the message to stderr for the TS node to capture.
        print(str(e), file=sys.stderr)
        sys.exit(1)

    finally:
        # --- Cleanup ---
        # Ensure all temporary files created during this run are deleted.
        for f in temp_files:
            try:
                if os.path.exists(f):
                    os.unlink(f)
            except Exception:
                # Ignore errors during cleanup
                pass


if __name__ == "__main__":
    main()

